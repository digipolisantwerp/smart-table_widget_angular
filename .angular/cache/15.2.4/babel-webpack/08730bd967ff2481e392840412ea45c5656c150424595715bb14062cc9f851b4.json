{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toDate;\nvar _index = _interopRequireDefault(require(\"date-fns/_lib/toInteger/index.js\"));\nvar _index2 = _interopRequireDefault(require(\"date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js\"));\nvar _index3 = _interopRequireDefault(require(\"../_lib/tzParseTimezone/index.js\"));\nvar _index4 = _interopRequireDefault(require(\"../_lib/tzPattern/index.js\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar MILLISECONDS_IN_HOUR = 3600000;\nvar MILLISECONDS_IN_MINUTE = 60000;\nvar DEFAULT_ADDITIONAL_DIGITS = 2;\nvar patterns = {\n  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,\n  datePattern: /^([0-9W+-]+)(.*)/,\n  plainTime: /:/,\n  // year tokens\n  YY: /^(\\d{2})$/,\n  YYY: [/^([+-]\\d{2})$/,\n  // 0 additional digits\n  /^([+-]\\d{3})$/,\n  // 1 additional digit\n  /^([+-]\\d{4})$/ // 2 additional digits\n  ],\n\n  YYYY: /^(\\d{4})/,\n  YYYYY: [/^([+-]\\d{4})/,\n  // 0 additional digits\n  /^([+-]\\d{5})/,\n  // 1 additional digit\n  /^([+-]\\d{6})/ // 2 additional digits\n  ],\n\n  // date tokens\n  MM: /^-(\\d{2})$/,\n  DDD: /^-?(\\d{3})$/,\n  MMDD: /^-?(\\d{2})-?(\\d{2})$/,\n  Www: /^-?W(\\d{2})$/,\n  WwwD: /^-?W(\\d{2})-?(\\d{1})$/,\n  HH: /^(\\d{2}([.,]\\d*)?)$/,\n  HHMM: /^(\\d{2}):?(\\d{2}([.,]\\d*)?)$/,\n  HHMMSS: /^(\\d{2}):?(\\d{2}):?(\\d{2}([.,]\\d*)?)$/,\n  // time zone tokens (to identify the presence of a tz)\n  timeZone: _index4.default\n};\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If an argument is a string, the function tries to parse it.\n * Function accepts complete ISO 8601 formats as well as partial implementations.\n * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601\n * If the function cannot parse the string or the values are invalid, it returns Invalid Date.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.\n *\n * @param {Date|String|Number} argument - the value to convert\n * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format\n * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.\n * @returns {Date} the parsed date in the local time zone\n * @throws {TypeError} 1 argument required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // Convert string '2014-02-11T11:30:30' to date:\n * var result = toDate('2014-02-11T11:30:30')\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert string '+02014101' to date,\n * // if the additional number of digits in the extended year format is 1:\n * var result = toDate('+02014101', {additionalDigits: 1})\n * //=> Fri Apr 11 2014 00:00:00\n */\n\nfunction toDate(argument, dirtyOptions) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present');\n  }\n  if (argument === null) {\n    return new Date(NaN);\n  }\n  var options = dirtyOptions || {};\n  var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : (0, _index.default)(options.additionalDigits);\n  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {\n    throw new RangeError('additionalDigits must be 0, 1 or 2');\n  } // Clone the date\n\n  if (argument instanceof Date || typeof argument === 'object' && Object.prototype.toString.call(argument) === '[object Date]') {\n    // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n    return new Date(argument.getTime());\n  } else if (typeof argument === 'number' || Object.prototype.toString.call(argument) === '[object Number]') {\n    return new Date(argument);\n  } else if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {\n    return new Date(NaN);\n  }\n  var dateStrings = splitDateString(argument);\n  var parseYearResult = parseYear(dateStrings.date, additionalDigits);\n  var year = parseYearResult.year;\n  var restDateString = parseYearResult.restDateString;\n  var date = parseDate(restDateString, year);\n  if (isNaN(date)) {\n    return new Date(NaN);\n  }\n  if (date) {\n    var timestamp = date.getTime();\n    var time = 0;\n    var offset;\n    if (dateStrings.time) {\n      time = parseTime(dateStrings.time);\n      if (isNaN(time)) {\n        return new Date(NaN);\n      }\n    }\n    if (dateStrings.timeZone || options.timeZone) {\n      offset = (0, _index3.default)(dateStrings.timeZone || options.timeZone, new Date(timestamp + time));\n      if (isNaN(offset)) {\n        return new Date(NaN);\n      }\n    } else {\n      // get offset accurate to hour in time zones that change offset\n      offset = (0, _index2.default)(new Date(timestamp + time));\n      offset = (0, _index2.default)(new Date(timestamp + time + offset));\n    }\n    return new Date(timestamp + time + offset);\n  } else {\n    return new Date(NaN);\n  }\n}\nfunction splitDateString(dateString) {\n  var dateStrings = {};\n  var parts = patterns.dateTimePattern.exec(dateString);\n  var timeString;\n  if (!parts) {\n    parts = patterns.datePattern.exec(dateString);\n    if (parts) {\n      dateStrings.date = parts[1];\n      timeString = parts[2];\n    } else {\n      dateStrings.date = null;\n      timeString = dateString;\n    }\n  } else {\n    dateStrings.date = parts[1];\n    timeString = parts[3];\n  }\n  if (timeString) {\n    var token = patterns.timeZone.exec(timeString);\n    if (token) {\n      dateStrings.time = timeString.replace(token[1], '');\n      dateStrings.timeZone = token[1].trim();\n    } else {\n      dateStrings.time = timeString;\n    }\n  }\n  return dateStrings;\n}\nfunction parseYear(dateString, additionalDigits) {\n  var patternYYY = patterns.YYY[additionalDigits];\n  var patternYYYYY = patterns.YYYYY[additionalDigits];\n  var token; // YYYY or ±YYYYY\n\n  token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);\n  if (token) {\n    var yearString = token[1];\n    return {\n      year: parseInt(yearString, 10),\n      restDateString: dateString.slice(yearString.length)\n    };\n  } // YY or ±YYY\n\n  token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);\n  if (token) {\n    var centuryString = token[1];\n    return {\n      year: parseInt(centuryString, 10) * 100,\n      restDateString: dateString.slice(centuryString.length)\n    };\n  } // Invalid ISO-formatted year\n\n  return {\n    year: null\n  };\n}\nfunction parseDate(dateString, year) {\n  // Invalid ISO-formatted year\n  if (year === null) {\n    return null;\n  }\n  var token;\n  var date;\n  var month;\n  var week; // YYYY\n\n  if (dateString.length === 0) {\n    date = new Date(0);\n    date.setUTCFullYear(year);\n    return date;\n  } // YYYY-MM\n\n  token = patterns.MM.exec(dateString);\n  if (token) {\n    date = new Date(0);\n    month = parseInt(token[1], 10) - 1;\n    if (!validateDate(year, month)) {\n      return new Date(NaN);\n    }\n    date.setUTCFullYear(year, month);\n    return date;\n  } // YYYY-DDD or YYYYDDD\n\n  token = patterns.DDD.exec(dateString);\n  if (token) {\n    date = new Date(0);\n    var dayOfYear = parseInt(token[1], 10);\n    if (!validateDayOfYearDate(year, dayOfYear)) {\n      return new Date(NaN);\n    }\n    date.setUTCFullYear(year, 0, dayOfYear);\n    return date;\n  } // yyyy-MM-dd or YYYYMMDD\n\n  token = patterns.MMDD.exec(dateString);\n  if (token) {\n    date = new Date(0);\n    month = parseInt(token[1], 10) - 1;\n    var day = parseInt(token[2], 10);\n    if (!validateDate(year, month, day)) {\n      return new Date(NaN);\n    }\n    date.setUTCFullYear(year, month, day);\n    return date;\n  } // YYYY-Www or YYYYWww\n\n  token = patterns.Www.exec(dateString);\n  if (token) {\n    week = parseInt(token[1], 10) - 1;\n    if (!validateWeekDate(year, week)) {\n      return new Date(NaN);\n    }\n    return dayOfISOWeekYear(year, week);\n  } // YYYY-Www-D or YYYYWwwD\n\n  token = patterns.WwwD.exec(dateString);\n  if (token) {\n    week = parseInt(token[1], 10) - 1;\n    var dayOfWeek = parseInt(token[2], 10) - 1;\n    if (!validateWeekDate(year, week, dayOfWeek)) {\n      return new Date(NaN);\n    }\n    return dayOfISOWeekYear(year, week, dayOfWeek);\n  } // Invalid ISO-formatted date\n\n  return null;\n}\nfunction parseTime(timeString) {\n  var token;\n  var hours;\n  var minutes; // hh\n\n  token = patterns.HH.exec(timeString);\n  if (token) {\n    hours = parseFloat(token[1].replace(',', '.'));\n    if (!validateTime(hours)) {\n      return NaN;\n    }\n    return hours % 24 * MILLISECONDS_IN_HOUR;\n  } // hh:mm or hhmm\n\n  token = patterns.HHMM.exec(timeString);\n  if (token) {\n    hours = parseInt(token[1], 10);\n    minutes = parseFloat(token[2].replace(',', '.'));\n    if (!validateTime(hours, minutes)) {\n      return NaN;\n    }\n    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;\n  } // hh:mm:ss or hhmmss\n\n  token = patterns.HHMMSS.exec(timeString);\n  if (token) {\n    hours = parseInt(token[1], 10);\n    minutes = parseInt(token[2], 10);\n    var seconds = parseFloat(token[3].replace(',', '.'));\n    if (!validateTime(hours, minutes, seconds)) {\n      return NaN;\n    }\n    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;\n  } // Invalid ISO-formatted time\n\n  return null;\n}\nfunction dayOfISOWeekYear(isoWeekYear, week, day) {\n  week = week || 0;\n  day = day || 0;\n  var date = new Date(0);\n  date.setUTCFullYear(isoWeekYear, 0, 4);\n  var fourthOfJanuaryDay = date.getUTCDay() || 7;\n  var diff = week * 7 + day + 1 - fourthOfJanuaryDay;\n  date.setUTCDate(date.getUTCDate() + diff);\n  return date;\n} // Validation functions\n\nvar DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nvar DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nfunction isLeapYearIndex(year) {\n  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;\n}\nfunction validateDate(year, month, date) {\n  if (month < 0 || month > 11) {\n    return false;\n  }\n  if (date != null) {\n    if (date < 1) {\n      return false;\n    }\n    var isLeapYear = isLeapYearIndex(year);\n    if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {\n      return false;\n    }\n    if (!isLeapYear && date > DAYS_IN_MONTH[month]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction validateDayOfYearDate(year, dayOfYear) {\n  if (dayOfYear < 1) {\n    return false;\n  }\n  var isLeapYear = isLeapYearIndex(year);\n  if (isLeapYear && dayOfYear > 366) {\n    return false;\n  }\n  if (!isLeapYear && dayOfYear > 365) {\n    return false;\n  }\n  return true;\n}\nfunction validateWeekDate(year, week, day) {\n  if (week < 0 || week > 52) {\n    return false;\n  }\n  if (day != null && (day < 0 || day > 6)) {\n    return false;\n  }\n  return true;\n}\nfunction validateTime(hours, minutes, seconds) {\n  if (hours != null && (hours < 0 || hours >= 25)) {\n    return false;\n  }\n  if (minutes != null && (minutes < 0 || minutes >= 60)) {\n    return false;\n  }\n  if (seconds != null && (seconds < 0 || seconds >= 60)) {\n    return false;\n  }\n  return true;\n}\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}
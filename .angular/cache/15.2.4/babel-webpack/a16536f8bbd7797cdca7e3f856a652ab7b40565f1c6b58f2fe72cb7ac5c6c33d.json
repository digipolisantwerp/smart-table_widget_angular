{"ast":null,"code":"import { Injectable, EventEmitter, Component, Input, Output, NgModule, Pipe, InjectionToken, PLATFORM_ID } from '@angular/core';\nimport { CommonModule, isPlatformBrowser } from '@angular/common';\nimport { IconModule } from '@acpaas-ui/ngx-icon';\nimport { FormArray, FormBuilder, FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { Subject } from 'rxjs';\nimport { map, tap, takeUntil } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/filter/services/filter.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/forms';\nimport * as ɵngcc2 from '@angular/common';\nimport * as ɵngcc3 from '@acpaas-ui/ngx-icon';\nfunction CheckboxFilterComponent_ul_0_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"li\")(1, \"form\", 3)(2, \"div\", 4)(3, \"div\", 5);\n    ɵngcc0.ɵɵelement(4, \"input\", 6);\n    ɵngcc0.ɵɵelementStart(5, \"label\", 7);\n    ɵngcc0.ɵɵtext(6);\n    ɵngcc0.ɵɵelementEnd()()()()();\n  }\n  if (rf & 2) {\n    const option_r2 = ctx.$implicit;\n    const i_r3 = ctx.index;\n    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"formGroup\", ctx_r1.form);\n    ɵngcc0.ɵɵadvance(3);\n    ɵngcc0.ɵɵproperty(\"formControl\", option_r2)(\"id\", ctx_r1.filter.options[i_r3].id)(\"name\", ctx_r1.filter.options[i_r3].name);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"for\", ctx_r1.filter.options[i_r3].id);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r1.filter.options[i_r3].name);\n  }\n}\nfunction CheckboxFilterComponent_ul_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"ul\", 1);\n    ɵngcc0.ɵɵtemplate(1, CheckboxFilterComponent_ul_0_li_1_Template, 7, 6, \"li\", 2);\n    ɵngcc0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.options.controls);\n  }\n}\nfunction InputFilterComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"div\", 2)(2, \"input\", 3);\n    ɵngcc0.ɵɵlistener(\"ngModelChange\", function InputFilterComponent_ng_container_1_Template_input_ngModelChange_2_listener() {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      const ctx_r1 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r1.onFilter(ctx_r1.value));\n    })(\"ngModelChange\", function InputFilterComponent_ng_container_1_Template_input_ngModelChange_2_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      const ctx_r3 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r3.value = $event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelement(3, \"aui-icon\", 4);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngModel\", ctx_r0.value)(\"id\", ctx_r0.filter.id)(\"placeholder\", ctx_r0.filter.name);\n    ɵngcc0.ɵɵattribute(\"aria-label\", ctx_r0.filter.name);\n  }\n}\nfunction SelectFilterComponent_ng_container_1_option_5_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"option\", 7);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const option_r2 = ctx.$implicit;\n    ɵngcc0.ɵɵproperty(\"value\", option_r2.id);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(option_r2.name);\n  }\n}\nfunction SelectFilterComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"label\", 2);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(3, \"div\", 3)(4, \"select\", 4);\n    ɵngcc0.ɵɵtemplate(5, SelectFilterComponent_ng_container_1_option_5_Template, 2, 2, \"option\", 5);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelement(6, \"aui-icon\", 6);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"for\", ctx_r0.filter.id);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\"\", ctx_r0.filter.name, \": \");\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"formControl\", ctx_r0.select)(\"id\", ctx_r0.filter.id)(\"name\", ctx_r0.filter.id);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.filter.options);\n  }\n}\nlet FilterService = /*#__PURE__*/(() => {\n  class FilterService {\n    /**\n     * @param {?} data\n     * @param {?} filters\n     * @return {?}\n     */\n    filterData(data, filters) {\n      filters.forEach(\n      /**\n      * @param {?} filter\n      * @return {?}\n      */\n      filter => {\n        data = filter.parseData(data);\n      });\n      return data;\n    }\n  }\n  FilterService.ɵfac = function FilterService_Factory(t) {\n    return new (t || FilterService)();\n  };\n  FilterService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: FilterService,\n    factory: FilterService.ɵfac\n  });\n  return FilterService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/filter/components/checkbox-filter/checkbox-filter.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet CheckboxFilterComponent = /*#__PURE__*/(() => {\n  class CheckboxFilterComponent {\n    /**\n     * @param {?} formBuilder\n     */\n    constructor(formBuilder) {\n      this.formBuilder = formBuilder;\n      this.update = new EventEmitter();\n      this.destroy$ = new Subject();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n      this.form = this.formBuilder.group({\n        options: this.buildCheckboxes(this.filter.options)\n      });\n      if (this.filter) {\n        this.value = this.filter.value;\n      }\n      this.options.valueChanges.pipe(map(\n      /**\n      * @param {?} array\n      * @return {?}\n      */\n      array => array.map(\n      /**\n      * @param {?} v\n      * @param {?} i\n      * @return {?}\n      */\n      (v, i) => {\n        return v === true ? this.filter.options[i] : null;\n      })), map(\n      /**\n      * @param {?} array\n      * @return {?}\n      */\n      array => array.filter(\n      /**\n      * @param {?} v\n      * @return {?}\n      */\n      v => v !== null)), tap(\n      /**\n      * @param {?} array\n      * @return {?}\n      */\n      array => this.value = array), tap(\n      /**\n      * @param {?} array\n      * @return {?}\n      */\n      array => this.update.next(array)), takeUntil(this.destroy$)).subscribe();\n    }\n    /**\n     * @private\n     * @param {?} options\n     * @return {?}\n     */\n    buildCheckboxes(options) {\n      return new FormArray([...options.map(\n      /**\n      * @param {?} option\n      * @return {?}\n      */\n      option => this.formBuilder.control(option.checked))]);\n    }\n    /**\n     * @return {?}\n     */\n    get options() {\n      return (/** @type {?} */this.form.get('options')\n      );\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    onFilter(value) {\n      this.update.emit(value);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n  }\n  CheckboxFilterComponent.ɵfac = function CheckboxFilterComponent_Factory(t) {\n    return new (t || CheckboxFilterComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FormBuilder));\n  };\n  CheckboxFilterComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: CheckboxFilterComponent,\n    selectors: [[\"aui-checkbox-filter\"]],\n    inputs: {\n      filter: \"filter\"\n    },\n    outputs: {\n      update: \"update\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[\"class\", \"a-list a-list--reset aui-checkbox-filter\", 4, \"ngIf\"], [1, \"a-list\", \"a-list--reset\", \"aui-checkbox-filter\"], [4, \"ngFor\", \"ngForOf\"], [3, \"formGroup\"], [1, \"a-input\"], [1, \"a-input__checkbox\"], [\"type\", \"checkbox\", 3, \"formControl\", \"id\", \"name\"], [3, \"for\"]],\n    template: function CheckboxFilterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, CheckboxFilterComponent_ul_0_Template, 2, 1, \"ul\", 0);\n      }\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.filter && ctx.filter.options && ctx.filter.id);\n      }\n    },\n    dependencies: [ɵngcc2.NgForOf, ɵngcc2.NgIf, ɵngcc1.ɵNgNoValidate, ɵngcc1.CheckboxControlValueAccessor, ɵngcc1.NgControlStatus, ɵngcc1.NgControlStatusGroup, ɵngcc1.FormControlDirective, ɵngcc1.FormGroupDirective],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n  return CheckboxFilterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nif (false) {\n  /** @type {?} */\n  CheckboxFilterComponent.prototype.filter;\n  /** @type {?} */\n  CheckboxFilterComponent.prototype.update;\n  /** @type {?} */\n  CheckboxFilterComponent.prototype.form;\n  /** @type {?} */\n  CheckboxFilterComponent.prototype.value;\n  /**\n   * @type {?}\n   * @private\n   */\n  CheckboxFilterComponent.prototype.destroy$;\n  /**\n   * @type {?}\n   * @private\n   */\n  CheckboxFilterComponent.prototype.formBuilder;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/filter/components/input-filter/input-filter.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet InputFilterComponent = /*#__PURE__*/(() => {\n  class InputFilterComponent {\n    constructor() {\n      this.update = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n      if (this.filter) {\n        this.value = this.filter.value;\n      }\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    onFilter(value) {\n      this.update.emit(value);\n    }\n  }\n  InputFilterComponent.ɵfac = function InputFilterComponent_Factory(t) {\n    return new (t || InputFilterComponent)();\n  };\n  InputFilterComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: InputFilterComponent,\n    selectors: [[\"aui-input-filter\"]],\n    inputs: {\n      filter: \"filter\"\n    },\n    outputs: {\n      update: \"update\"\n    },\n    decls: 2,\n    vars: 1,\n    consts: [[1, \"a-input\", \"has-icon-right\", \"aui-input-filter\"], [4, \"ngIf\"], [1, \"a-input__wrapper\"], [\"type\", \"text\", 3, \"ngModel\", \"id\", \"placeholder\", \"ngModelChange\"], [\"name\", \"ai-search\"]],\n    template: function InputFilterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵtemplate(1, InputFilterComponent_ng_container_1_Template, 4, 4, \"ng-container\", 1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.filter);\n      }\n    },\n    dependencies: [ɵngcc2.NgIf, ɵngcc3.IconComponent, ɵngcc1.DefaultValueAccessor, ɵngcc1.NgControlStatus, ɵngcc1.NgModel],\n    encapsulation: 2\n  });\n  return InputFilterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nif (false) {\n  /** @type {?} */\n  InputFilterComponent.prototype.filter;\n  /** @type {?} */\n  InputFilterComponent.prototype.update;\n  /** @type {?} */\n  InputFilterComponent.prototype.value;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/filter/components/select-filter/select-filter.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet SelectFilterComponent = /*#__PURE__*/(() => {\n  class SelectFilterComponent {\n    constructor() {\n      this.update = new EventEmitter();\n      this.select = new FormControl();\n      this.destroy$ = new Subject();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n      if (this.filter && this.filter.value) {\n        this.value = this.filter.value;\n        this.select.setValue(this.filter.value.id);\n      }\n      this.select.valueChanges.pipe(map(\n      /**\n      * @param {?} id\n      * @return {?}\n      */\n      id => this.filter.options.find(\n      /**\n      * @param {?} option\n      * @return {?}\n      */\n      option => option.id === id)), tap(\n      /**\n      * @param {?} v\n      * @return {?}\n      */\n      v => this.update.next(v)), takeUntil(this.destroy$)).subscribe();\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    onFilter(value) {\n      this.update.emit(value);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n  }\n  SelectFilterComponent.ɵfac = function SelectFilterComponent_Factory(t) {\n    return new (t || SelectFilterComponent)();\n  };\n  SelectFilterComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: SelectFilterComponent,\n    selectors: [[\"aui-select-filter\"]],\n    inputs: {\n      filter: \"filter\"\n    },\n    outputs: {\n      update: \"update\"\n    },\n    decls: 2,\n    vars: 1,\n    consts: [[1, \"a-input\", \"has-icon-right\", \"aui-select-filter\"], [4, \"ngIf\"], [1, \"a-input__label\", \"a-input__label--inline\", 3, \"for\"], [1, \"a-input__wrapper\", \"a-input__wrapper--inline\"], [3, \"formControl\", \"id\", \"name\"], [3, \"value\", 4, \"ngFor\", \"ngForOf\"], [\"name\", \"ai-arrow-down-1\"], [3, \"value\"]],\n    template: function SelectFilterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵtemplate(1, SelectFilterComponent_ng_container_1_Template, 7, 6, \"ng-container\", 1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.filter && ctx.filter.options && ctx.filter.id);\n      }\n    },\n    dependencies: [ɵngcc2.NgForOf, ɵngcc2.NgIf, ɵngcc3.IconComponent, ɵngcc1.NgSelectOption, ɵngcc1.ɵNgSelectMultipleOption, ɵngcc1.SelectControlValueAccessor, ɵngcc1.NgControlStatus, ɵngcc1.FormControlDirective],\n    encapsulation: 2\n  });\n  return SelectFilterComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nif (false) {\n  /** @type {?} */\n  SelectFilterComponent.prototype.filter;\n  /** @type {?} */\n  SelectFilterComponent.prototype.update;\n  /** @type {?} */\n  SelectFilterComponent.prototype.select;\n  /** @type {?} */\n  SelectFilterComponent.prototype.value;\n  /**\n   * @type {?}\n   * @private\n   */\n  SelectFilterComponent.prototype.destroy$;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/filter/filter.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet FilterModule = /*#__PURE__*/(() => {\n  class FilterModule {}\n  FilterModule.ɵfac = function FilterModule_Factory(t) {\n    return new (t || FilterModule)();\n  };\n  FilterModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: FilterModule\n  });\n  FilterModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [FilterService],\n    imports: [CommonModule, IconModule, FormsModule, ReactiveFormsModule]\n  });\n  return FilterModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FilterModule, {\n    declarations: function () {\n      return [CheckboxFilterComponent, InputFilterComponent, SelectFilterComponent];\n    },\n    imports: function () {\n      return [CommonModule, IconModule, FormsModule, ReactiveFormsModule];\n    },\n    exports: function () {\n      return [CheckboxFilterComponent, InputFilterComponent, SelectFilterComponent];\n    }\n  });\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/filter/classes/filter.class.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass Filter {\n  /**\n   * @param {?} data\n   * @return {?}\n   */\n  parseData(data) {\n    return this.parse(data, this.value);\n  }\n}\nif (false) {\n  /** @type {?} */\n  Filter.prototype.id;\n  /** @type {?} */\n  Filter.prototype.name;\n  /** @type {?} */\n  Filter.prototype.options;\n  /** @type {?} */\n  Filter.prototype.value;\n  /** @type {?} */\n  Filter.prototype.parse;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/labels/utils/interpolation.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst interpolate =\n/**\n* @param {?} label\n* @param {?=} replaceData\n* @return {?}\n*/\n(label, replaceData) => {\n  if (!replaceData) {\n    return label;\n  }\n  /** @type {?} */\n  const escapeStringRegExp =\n  /**\n  * @param {?} prop\n  * @return {?}\n  */\n  prop => prop.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&');\n  /** @type {?} */\n  const pattern = new RegExp(`\\%{(${Object.keys(replaceData).map(escapeStringRegExp).join('|')})\\}`, 'g');\n  return label.replace(pattern,\n  /**\n  * @param {?} match\n  * @param {?} prop\n  * @return {?}\n  */\n  (match, prop) => replaceData[prop] ? String(replaceData[prop]) : '');\n};\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/labels/pipes/interpolate-label.pipe.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet InterpolateLabelPipe = /*#__PURE__*/(() => {\n  class InterpolateLabelPipe {\n    /**\n     * @param {?} label\n     * @param {?} replaceData\n     * @return {?}\n     */\n    transform(label, replaceData) {\n      if (!replaceData || !label) {\n        return label;\n      }\n      return interpolate(label, replaceData);\n    }\n  }\n  InterpolateLabelPipe.ɵfac = function InterpolateLabelPipe_Factory(t) {\n    return new (t || InterpolateLabelPipe)();\n  };\n  InterpolateLabelPipe.ɵpipe = /*@__PURE__*/ɵngcc0.ɵɵdefinePipe({\n    name: \"interpolateLabel\",\n    type: InterpolateLabelPipe,\n    pure: true\n  });\n  return InterpolateLabelPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/labels/pipes/pluralize-label.pipe.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet PluralizeLabelPipe = /*#__PURE__*/(() => {\n  class PluralizeLabelPipe {\n    /**\n     * @param {?} label\n     * @param {?} count\n     * @return {?}\n     */\n    transform(label, count) {\n      if (!label || typeof label === 'string') {\n        return (/** @type {?} */label\n        );\n      }\n      return count === 1 ? label.singular : label.plural;\n    }\n  }\n  PluralizeLabelPipe.ɵfac = function PluralizeLabelPipe_Factory(t) {\n    return new (t || PluralizeLabelPipe)();\n  };\n  PluralizeLabelPipe.ɵpipe = /*@__PURE__*/ɵngcc0.ɵɵdefinePipe({\n    name: \"pluralizeLabel\",\n    type: PluralizeLabelPipe,\n    pure: true\n  });\n  return PluralizeLabelPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/labels/labels.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet LabelsModule = /*#__PURE__*/(() => {\n  class LabelsModule {}\n  LabelsModule.ɵfac = function LabelsModule_Factory(t) {\n    return new (t || LabelsModule)();\n  };\n  LabelsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: LabelsModule\n  });\n  LabelsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return LabelsModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LabelsModule, {\n    declarations: [PluralizeLabelPipe, InterpolateLabelPipe],\n    exports: [PluralizeLabelPipe, InterpolateLabelPipe]\n  });\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/window/services/window.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/* Create a new injection token for injecting the window into a component. */\n/** @type {?} */\nconst WINDOW = new InjectionToken('WindowToken');\n/* Define abstract class for obtaining reference to the global window object. */\n/**\n * @abstract\n */\nclass WindowRef {\n  /**\n   * @return {?}\n   */\n  get nativeWindow() {\n    throw new Error('Not implemented.');\n  }\n}\n/* Define class that implements the abstract class and returns the native window object. */\nlet BrowserWindowRef = /*#__PURE__*/(() => {\n  class BrowserWindowRef extends WindowRef {\n    constructor() {\n      super();\n    }\n    /**\n     * @return {?}\n     */\n    get nativeWindow() {\n      return window;\n    }\n  }\n  BrowserWindowRef.ɵfac = function BrowserWindowRef_Factory(t) {\n    return new (t || BrowserWindowRef)();\n  };\n  BrowserWindowRef.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: BrowserWindowRef,\n    factory: BrowserWindowRef.ɵfac\n  });\n\n  /* Create a factory function that returns the native window object. */\n  /**\n   * @param {?} browserWindowRef\n   * @param {?} platformId\n   * @return {?}\n   */\n  return BrowserWindowRef;\n})();\nfunction windowFactory(browserWindowRef, platformId) {\n  if (isPlatformBrowser(platformId)) {\n    return browserWindowRef.nativeWindow;\n  }\n  return {};\n}\n/* Create a injectable provider for the WindowRef token that uses the BrowserWindowRef class. */\n/** @type {?} */\nconst browserWindowProvider = {\n  provide: WindowRef,\n  useClass: BrowserWindowRef\n};\n/* Create an injectable provider that uses the windowFactory function for returning the native window object. */\n/** @type {?} */\nconst windowProvider = {\n  provide: WINDOW,\n  useFactory: windowFactory,\n  deps: [WindowRef, PLATFORM_ID]\n};\n/* Create an array of providers. */\n/** @type {?} */\nconst WINDOW_PROVIDERS = [browserWindowProvider, windowProvider];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/window/window.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet WindowModule = /*#__PURE__*/(() => {\n  class WindowModule {}\n  WindowModule.ɵfac = function WindowModule_Factory(t) {\n    return new (t || WindowModule)();\n  };\n  WindowModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: WindowModule\n  });\n  WindowModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [WINDOW_PROVIDERS]\n  });\n  return WindowModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/interval/classes/interval.model.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @abstract\n * @template T\n */\nclass IntervalModel {\n  /**\n   * @param {?} min\n   * @param {?} max\n   */\n  constructor(min, max) {\n    this.min = min;\n    this.max = max;\n    this.bound = 'bounded';\n    this.meaning = 'OR';\n  }\n}\nif (false) {\n  /** @type {?} */\n  IntervalModel.prototype.bound;\n  /** @type {?} */\n  IntervalModel.prototype.type;\n  /** @type {?} */\n  IntervalModel.prototype.meaning;\n  /** @type {?} */\n  IntervalModel.prototype.min;\n  /** @type {?} */\n  IntervalModel.prototype.max;\n  /**\n   * @abstract\n   * @param {?} value\n   * @return {?}\n   */\n  IntervalModel.prototype.isInRange = function (value) {};\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/interval/classes/generic.interval.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass GenericInterval extends IntervalModel {\n  /**\n   * @private\n   * @param {?} value\n   * @return {?}\n   */\n  checkIsInRange(value) {\n    switch (this.type) {\n      case 'closed':\n        return value >= this.min && value <= this.max;\n      case 'open':\n        return value > this.min && value < this.max;\n      case 'leftopen':\n        if (this.bound === 'bounded') {\n          return value > this.min && value <= this.max;\n        } else if (this.bound === 'unbounded') {\n          return value <= this.max;\n        }\n        return false;\n      case 'rightopen':\n        if (this.bound === 'bounded') {\n          return value >= this.min && value < this.max;\n        } else if (this.bound === 'unbounded') {\n          return value >= this.min;\n        }\n        return false;\n      default:\n        return false;\n    }\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  isInRange(value) {\n    return this.meaning === 'OR' ? this.checkIsInRange(value) : !this.checkIsInRange(value);\n  }\n  /**\n   * @return {?}\n   */\n  toString() {\n    return String(`\n    ${this.type === 'closed' || this.type === 'rightopen' ? '[' : ']'}\n    ${this.bound === 'unbounded' && this.type === 'leftopen' ? '-infinity' : this.min}\n    ,\n    ${this.bound === 'unbounded' && this.type === 'rightopen' ? '+infinity' : this.max}\n    ${this.type === 'closed' || this.type === 'leftopen' ? ']' : '['}\n    `).replace(/\\n/g, '').replace(/ /g, '').trim();\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/interval/classes/date.interval.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass DateInterval extends IntervalModel {\n  /**\n   * @param {?} min\n   * @param {?} max\n   */\n  constructor(min, max) {\n    super(min, max);\n    if (!min && !max) {\n      throw new Error('Error creating date interval, please provide at least min or max.');\n    } else if (!min) {\n      this.bound = 'unbounded';\n      this.type = 'leftopen';\n    } else if (!max) {\n      this.bound = 'unbounded';\n      this.type = 'rightopen';\n    } else {\n      this.type = 'closed';\n    }\n  }\n  /**\n   * @param {?} one\n   * @param {?} two\n   * @return {?}\n   */\n  static isSameOrAfter(one, two) {\n    return two.getTime() >= one.getTime();\n  }\n  /**\n   * @param {?} one\n   * @param {?} two\n   * @return {?}\n   */\n  static isSameOrBefore(one, two) {\n    return two.getTime() <= one.getTime();\n  }\n  /**\n   * @param {?} one\n   * @param {?} two\n   * @return {?}\n   */\n  static isAfter(one, two) {\n    return two.getTime() > one.getTime();\n  }\n  /**\n   * @param {?} one\n   * @param {?} two\n   * @return {?}\n   */\n  static isBefore(one, two) {\n    return two.getTime() < one.getTime();\n  }\n  /**\n   * @private\n   * @param {?} value\n   * @return {?}\n   */\n  checkIsInRange(value) {\n    switch (this.type) {\n      case 'closed':\n        return DateInterval.isSameOrAfter(this.min, value) && DateInterval.isSameOrBefore(this.max, value);\n      case 'open':\n        return DateInterval.isAfter(this.min, value) && DateInterval.isBefore(this.max, value);\n      case 'leftopen':\n        if (this.bound === 'bounded') {\n          return DateInterval.isAfter(this.min, value) && DateInterval.isSameOrBefore(this.max, value);\n        } else if (this.bound === 'unbounded') {\n          return DateInterval.isSameOrBefore(this.max, value);\n        }\n        return false;\n      case 'rightopen':\n        if (this.bound === 'bounded') {\n          return DateInterval.isSameOrAfter(this.min, value) && DateInterval.isBefore(this.max, value);\n        } else if (this.bound === 'unbounded') {\n          return DateInterval.isSameOrAfter(this.min, value);\n        }\n        return false;\n      default:\n        return false;\n    }\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  isInRange(value) {\n    return this.meaning === 'OR' ? this.checkIsInRange(value) : !this.checkIsInRange(value);\n  }\n  /**\n   * @return {?}\n   */\n  toString() {\n    return String(`\n    ${this.type === 'closed' || this.type === 'rightopen' ? '[' : ']'}\n    ${this.bound === 'unbounded' && this.type === 'leftopen' ? '-infinity' : this.min.toISOString()}\n    ,\n    ${this.bound === 'unbounded' && this.type === 'rightopen' ? '+infinity' : this.max.toISOString()}\n    ${this.type === 'closed' || this.type === 'leftopen' ? ']' : '['}\n    `).replace(/\\n/g, '').replace(/ /g, '').trim();\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/interval/classes/interval.builder.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n */\nclass IntervalBuilder {\n  /**\n   * @param {?} model\n   */\n  constructor(model) {\n    this.model = model;\n  }\n  /**\n   * @param {?} min\n   * @param {?} max\n   * @return {?}\n   */\n  static dateInterval(min, max) {\n    return new IntervalBuilder(new DateInterval(min, max));\n  }\n  /**\n   * @param {?} min\n   * @param {?} max\n   * @return {?}\n   */\n  static genericInterval(min, max) {\n    return new IntervalBuilder(new GenericInterval(min, max));\n  }\n  /**\n   * @param {?} min\n   * @param {?} max\n   * @return {?}\n   */\n  static numberInterval(min, max) {\n    return IntervalBuilder.genericInterval(min, max);\n  }\n  /**\n   * @return {?}\n   */\n  openInterval() {\n    this.model.type = 'open';\n    return this;\n  }\n  /**\n   * @return {?}\n   */\n  leftOpenInterval() {\n    this.model.type = 'leftopen';\n    return this;\n  }\n  /**\n   * @return {?}\n   */\n  rightOpenInterval() {\n    this.model.type = 'rightopen';\n    return this;\n  }\n  /**\n   * @return {?}\n   */\n  closedInterval() {\n    this.model.type = 'closed';\n    return this;\n  }\n  /**\n   * @return {?}\n   */\n  bounded() {\n    this.model.bound = 'bounded';\n    return this;\n  }\n  /**\n   * @return {?}\n   */\n  unbounded() {\n    this.model.bound = 'unbounded';\n    return this;\n  }\n  /**\n   * @return {?}\n   */\n  not() {\n    this.model.meaning = 'NOR';\n    return this;\n  }\n  /**\n   * @return {?}\n   */\n  build() {\n    return this.model;\n  }\n}\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  IntervalBuilder.prototype.model;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: acpaas-ui-ngx-utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { CheckboxFilterComponent, DateInterval, Filter, FilterModule, FilterService, GenericInterval, InputFilterComponent, InterpolateLabelPipe, IntervalBuilder, LabelsModule, PluralizeLabelPipe, SelectFilterComponent, WINDOW, WINDOW_PROVIDERS, WindowModule, interpolate, WindowRef as ɵa, BrowserWindowRef as ɵb, windowFactory as ɵc, IntervalModel as ɵd };\n\n//# sourceMappingURL=acpaas-ui-ngx-utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}